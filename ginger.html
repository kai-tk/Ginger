<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Learning Dictionary</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        color-scheme: light dark;
      }
      body {
        margin: 0;
        padding: 0;
        background: #f3f4f6;
      }
      .wrapper {
        max-width: 1100px;
        margin: 0 auto;
        padding: 1.5rem 1rem 3rem;
      }
      h1 {
        margin: 0 0 0.25rem;
        font-size: 1.6rem;
      }
      .sub {
        margin: 0 0 1rem;
        color: #6b7280;
        font-size: 0.9rem;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        background: #ffffff;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 12px 25px rgba(15, 23, 42, 0.12);
      }
      thead {
        background: #e5e7eb;
      }
      th,
      td {
        padding: 0.5rem 0.6rem;
        border-bottom: 1px solid #e5e7eb;
        vertical-align: top;
        font-size: 0.9rem;
      }
      th {
        text-align: left;
        white-space: nowrap;
      }
      tbody tr:nth-child(even) {
        background: #f9fafb;
      }
      .headword {
        font-weight: 600;
      }
      input.translation-input {
        width: 80%;
        box-sizing: border-box;
        padding: 0.25rem 0.35rem;
        font-size: 0.9rem;
      }
      .meaning-cell {
        line-height: 1.8;
        width: 40%;
      }

      .ref-list {
        font-size: 0.8rem;
        color: #4b5563;
        width: 12%;
        white-space: normal;
        word-break: break-word;
      }

      .ref-chip {
        display: inline-block;
        padding: 0.05rem 0.3rem;
        margin: 0 0.15rem 0.15rem 0;
        border-radius: 9999px;
        background: #e5e7eb;
        cursor: pointer;
      }
      .dict-word {
        position: relative;
        cursor: help;
        text-decoration: underline dotted #9ca3af;
        text-underline-offset: 0.2em;
      }
      ruby {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        white-space: nowrap;
        margin: 0 0.05em;
      }
      ruby > .base-word {
        order: 0;
      }
      ruby > rt {
        order: 1;
        font-size: 0.6em;
        line-height: 1.1;
        padding: 0.05em 0.2em 0;
        min-width: 1.5em;
        display: inline-block;
        border-bottom: 1px dashed #9ca3af;
      }
      ruby > rt.ruby-empty {
        opacity: 0.7;
      }
      .tooltip-box {
        position: fixed;
        z-index: 9999;
        max-width: 320px;
        padding: 0.4rem 0.55rem;
        font-size: 0.8rem;
        background: rgba(17, 24, 39, 0.96);
        color: #f9fafb;
        border-radius: 0.4rem;
        box-shadow: 0 10px 25px rgba(15, 23, 42, 0.4);
        white-space: normal;
        opacity: 0;
        pointer-events: none;
        transform: translateY(4px);
        transition: opacity 0.08s ease-out, transform 0.08s ease-out;
      }
      .tooltip-headword {
        font-weight: 600;
        margin-bottom: 0.25rem;
        font-size: 0.9rem;
      }
      .tooltip-body {
        margin-top: 0.1rem;
      }
      .tooltip-box.visible {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0);
      }
      .footnote {
        margin-top: 0.75rem;
        font-size: 0.75rem;
        color: #9ca3af;
      }
      .translation-locked {
        color: #9ca3af;
        font-size: 0.8rem;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <h1>Learning Dictionary</h1>
      <p class="sub">
        Headwords and definitions are written in the same language.<br />
        Ruby text itself is editable. Click a word to see its definition in a
        tooltip.
      </p>

      <table>
        <thead>
          <tr>
            <th>Headword</th>
            <th>Translation</th>
            <th>Meaning</th>
            <th>References</th>
          </tr>
        </thead>
        <tbody id="dict-body"></tbody>
      </table>

      <p class="footnote">
        Translations are stored in a cookie in this browser.
      </p>

      <div id="tooltip-layer-0" class="tooltip-box"></div>
      <div id="tooltip-layer-1" class="tooltip-box"></div>
      <div id="tooltip-layer-2" class="tooltip-box"></div>
    </div>

    <script>
      let ENTRIES = [];
      const COOKIE_NAME = "learning_dict_data";
      let headwordToEntry = {};
      const tooltipLayers = [];
      let tooltipHandlersInstalled = false;

      function isUpperLike(word) {
        return /^[A-Z0-9]+$/.test(word);
      }

      function setCookie(name, value, days) {
        const d = new Date();
        d.setTime(d.getTime() + days * 24 * 60 * 60 * 1000);
        const expires = "expires=" + d.toUTCString();
        document.cookie =
          name + "=" + encodeURIComponent(value) + ";" + expires + ";path=/";
      }

      function getCookie(name) {
        const decodedCookie = decodeURIComponent(document.cookie);
        const ca = decodedCookie.split(";");
        const prefix = name + "=";
        for (let c of ca) {
          c = c.trim();
          if (c.indexOf(prefix) === 0) {
            return c.substring(prefix.length, c.length);
          }
        }
        return "";
      }

      function loadUserData() {
        try {
          const raw = getCookie(COOKIE_NAME);
          if (!raw) return {};
          const data = JSON.parse(raw);
          if (typeof data !== "object" || data === null) return {};
          return data;
        } catch {
          return {};
        }
      }

      function saveUserData(userData) {
        setCookie(COOKIE_NAME, JSON.stringify(userData), 365);
      }

      function escapeHtml(str) {
        return String(str)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      const SPECIAL_RUBY_HEADWORDS = new Set([
        "a.",
        "bu.",
        "cj.",
        "e.",
        "hh.",
        "i.",
        "k.",
        "p.",
        "q.",
        "r.",
        "sj.",
      ]);

      function parseCsv(text) {
        const lines = text.split(/\r?\n/);
        if (!lines.length) return [];
        const entries = [];
        let current = null;

        function unquote(s) {
          s = s.trim();
          if (s.startsWith('"') && s.endsWith('"')) {
            s = s.slice(1, -1).replace(/""/g, '"');
          }
          return s;
        }

        for (let i = 1; i < lines.length; i++) {
          const line = lines[i];
          if (!line.trim()) continue;
          const idx = line.indexOf(",");
          if (idx === -1) continue;
          const wRaw = line.slice(0, idx);
          const dRaw = line.slice(idx + 1);
          const word = unquote(wRaw);
          const def = unquote(dRaw);
          if (word) {
            if (current) entries.push(current);
            current = { headword: word, meaning: def };
          } else if (current && def) {
            current.meaning += " " + def;
          }
        }
        if (current) entries.push(current);
        return entries.map((e, i) => ({
          id: "e" + i,
          headword: e.headword,
          meaning: e.meaning,
        }));
      }

      function computeReferences() {
        ENTRIES.forEach((entry) => {
          entry._refs = [];
        });
        for (const A of ENTRIES) {
          for (const B of ENTRIES) {
            if (A === B) continue;
            const re = new RegExp(
              "\\b" + escapeRegExp(B.headword) + "\\b",
              "i"
            );
            if (re.test(A.meaning)) {
              B._refs.push(A.headword);
            }
          }
        }
      }

      function renderMeaningHtml(text, translations) {
        let result = escapeHtml(text);
        const headwords = ENTRIES.map((e) => e.headword).sort(
          (a, b) => b.length - a.length
        );

        headwords.forEach((hw) => {
          const translation = translations[hw] || "";
          const escapedHw = escapeHtml(hw);
          const escapedTr = escapeHtml(translation);

          const rtClass = translation ? "" : " ruby-empty";

          const replacement =
            `<span class="dict-word" data-headword="${escapedHw}">` +
            `<ruby>` +
            `<span class="base-word">${escapedHw}</span>` +
            `<rt class="ruby-editable${rtClass}">${escapedTr}</rt>` +
            `</ruby>` +
            `</span>`;

          if (SPECIAL_RUBY_HEADWORDS.has(hw)) {
            const re = new RegExp(
              "(^|[^A-Za-z])(" + escapeRegExp(hw) + ")(?![A-Za-z])",
              "g"
            );
            result = result.replace(re, (match, prefix, word) => {
              return prefix + replacement;
            });
          } else {
            const re = new RegExp("\\b" + escapeRegExp(hw) + "\\b", "g");
            result = result.replace(re, replacement);
          }
        });

        return result;
      }

      function buildTable() {
        const tbody = document.getElementById("dict-body");
        const userData = loadUserData();
        computeReferences();

        ENTRIES.forEach((entry) => {
          const tr = document.createElement("tr");
          tr.dataset.entryId = entry.id;

          const tdHead = document.createElement("td");
          tdHead.className = "headword";
          tdHead.textContent = entry.headword;
          tr.appendChild(tdHead);

          const tdTrans = document.createElement("td");
          const locked = isUpperLike(entry.headword);
          const stored = userData[entry.id];

          if (locked) {
            tdTrans.textContent = "â€”";
            tdTrans.classList.add("translation-locked");
          } else {
            const input = document.createElement("input");
            input.type = "text";
            input.className = "translation-input";
            input.dataset.entryId = entry.id;
            input.dataset.headword = entry.headword;
            input.value = stored?.translation || "";
            input.addEventListener("change", () => {
              const data = loadUserData();
              if (!data[entry.id]) data[entry.id] = {};
              data[entry.id].translation = input.value;
              saveUserData(data);
              updateMeaningsForHeadword(entry.headword);
            });
            tdTrans.appendChild(input);
          }
          tr.appendChild(tdTrans);

          const tdMeaning = document.createElement("td");
          tdMeaning.className = "meaning-cell";
          tdMeaning.dataset.entryId = entry.id;
          tr.appendChild(tdMeaning);

          const tdRef = document.createElement("td");
          tdRef.className = "ref-list";
          tdRef.dataset.entryId = entry.id;
          tr.appendChild(tdRef);

          tbody.appendChild(tr);
        });

        updateAllMeaningsFromInputs();
        renderReferences();
      }

      function collectTranslationsFromInputs() {
        const inputs = document.querySelectorAll(".translation-input");
        const translations = {};
        inputs.forEach((input) => {
          const hw = input.dataset.headword;
          translations[hw] = input.value || "";
        });
        return translations;
      }

      function updateAllMeaningsFromInputs() {
        const translations = collectTranslationsFromInputs();
        ENTRIES.forEach((entry) => {
          const cell = document.querySelector(
            `.meaning-cell[data-entry-id="${entry.id}"]`
          );
          if (!cell) return;
          cell.innerHTML = renderMeaningHtml(entry.meaning, translations);
        });
        attachTooltipHandlers();
      }

      function updateMeaningsForHeadword(headword) {
        const translations = collectTranslationsFromInputs();
        const entry = headwordToEntry[headword];
        if (!entry) return;

        const selfCell = document.querySelector(
          `.meaning-cell[data-entry-id="${entry.id}"]`
        );
        if (selfCell) {
          selfCell.innerHTML = renderMeaningHtml(entry.meaning, translations);
        }

        const refs = entry._refs || [];
        refs.forEach((refHw) => {
          const refEntry = headwordToEntry[refHw];
          if (!refEntry) return;
          const refCell = document.querySelector(
            `.meaning-cell[data-entry-id="${refEntry.id}"]`
          );
          if (refCell) {
            refCell.innerHTML = renderMeaningHtml(
              refEntry.meaning,
              translations
            );
          }
        });
      }

      function renderReferences() {
        ENTRIES.forEach((entry) => {
          const cell = document.querySelector(
            `.ref-list[data-entry-id="${entry.id}"]`
          );
          if (!cell) return;
          cell.innerHTML = "";
          if (!entry._refs || entry._refs.length === 0) {
            cell.textContent = "-";
            return;
          }
          entry._refs.forEach((hw) => {
            const chip = document.createElement("span");
            chip.className = "ref-chip";
            chip.textContent = hw;
            chip.addEventListener("click", () => {
              const targetRow = [...document.querySelectorAll("tr")].find(
                (tr) => tr.querySelector(".headword")?.textContent === hw
              );
              if (targetRow) {
                targetRow.scrollIntoView({
                  behavior: "smooth",
                  block: "center",
                });
                targetRow.style.outline = "2px solid #3b82f6";
                setTimeout(() => {
                  targetRow.style.outline = "";
                }, 1500);
              }
            });
            cell.appendChild(chip);
          });
        });
      }

      function initTooltipLayers() {
        tooltipLayers[0] = document.getElementById("tooltip-layer-0");
        tooltipLayers[1] = document.getElementById("tooltip-layer-1");
        tooltipLayers[2] = document.getElementById("tooltip-layer-2");
      }

      function hideTooltipFrom(level) {
        for (let i = level; i < tooltipLayers.length; i++) {
          const layer = tooltipLayers[i];
          if (!layer) continue;
          layer.classList.remove("visible");
          layer.innerHTML = "";
        }
      }

      function showTooltip(level, anchorEl, headword) {
        const layer = tooltipLayers[level];
        if (!layer) return;
        const entry = headwordToEntry[headword];
        const meaning = entry?.meaning || "";
        const headEsc = escapeHtml(headword);
        const meaningHtml = renderMeaningHtml(
          meaning,
          collectTranslationsFromInputs()
        );
        layer.innerHTML =
          `<div class="tooltip-headword">${headEsc}</div>` +
          `<div class="tooltip-body">${meaningHtml}</div>`;
        layer.classList.add("visible");
        layer.style.left = "0px";
        layer.style.top = "0px";

        const margin = 8;
        let x, y;

        if (level === 0) {
          const anchorRect = anchorEl.getBoundingClientRect();
          const tipRect = layer.getBoundingClientRect();

          x = anchorRect.left;

          if (x + tipRect.width > window.innerWidth - margin) {
            x = window.innerWidth - tipRect.width - margin;
          }
          if (x < margin) x = margin;

          y = anchorRect.bottom + margin;

          if (y + tipRect.height > window.innerHeight - margin) {
            y = window.innerHeight - tipRect.height - margin;
            if (y < margin) y = margin;
          }
        } else {
          const prevLayer = tooltipLayers[level - 1];
          if (!prevLayer || !prevLayer.classList.contains("visible")) {
            return showTooltip(0, anchorEl, headword);
          }
          const prevRect = prevLayer.getBoundingClientRect();
          const tipRect = layer.getBoundingClientRect();
          const indentX = 16 * level;
          x = prevRect.left + indentX;
          if (x + tipRect.width > window.innerWidth - margin) {
            x = window.innerWidth - tipRect.width - margin;
          }
          if (x < margin) x = margin;
          y = prevRect.bottom + margin;
          if (y + tipRect.height > window.innerHeight - margin) {
            y = window.innerHeight - tipRect.height - margin;
            if (y < margin) y = margin;
          }
        }
        layer.style.left = x + "px";
        layer.style.top = y + "px";
      }

      function getLevelForElement(el) {
        if (el.closest("#tooltip-layer-2")) return 3;
        if (el.closest("#tooltip-layer-1")) return 2;
        if (el.closest("#tooltip-layer-0")) return 1;
        return 0;
      }

      function onDictWordClick(e) {
        const wordEl = e.target.closest(".dict-word");
        if (!wordEl) return;
        e.stopPropagation();
        const base = wordEl.querySelector(".base-word");
        const headword = base ? base.textContent.trim() : "";
        if (!headword) return;
        const contextLevel = getLevelForElement(wordEl);
        const layerIndex = contextLevel;
        if (layerIndex >= tooltipLayers.length) return;
        hideTooltipFrom(layerIndex);
        showTooltip(layerIndex, wordEl, headword);
      }

      function onDocumentClickClose(e) {
        if (
          e.target.closest(".tooltip-box") ||
          e.target.closest(".dict-word")
        ) {
          return;
        }
        hideTooltipFrom(0);
      }

      function attachTooltipHandlers() {
        if (tooltipHandlersInstalled) return;
        tooltipHandlersInstalled = true;
        initTooltipLayers();
        document.addEventListener("click", onDictWordClick);
        document.addEventListener("click", onDocumentClickClose);
      }

      async function loadDictionary() {
        const res = await fetch("dictionary.csv");
        const csvText = await res.text();
        ENTRIES = parseCsv(csvText);

        headwordToEntry = {};
        ENTRIES.forEach((e) => (headwordToEntry[e.headword] = e));

        buildTable();
        attachTooltipHandlers();
      }

      document.addEventListener("DOMContentLoaded", async () => {
        loadDictionary();
      });
    </script>
  </body>
</html>
